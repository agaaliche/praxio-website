const fs = require('fs');
const path = require('path');

console.log('üîß Generating TypeScript types from translations...\n');

// Read English translations as the source of truth
const localesDir = path.join(__dirname, '../i18n/locales');
const enPath = path.join(localesDir, 'en.json');

if (!fs.existsSync(enPath)) {
    console.error('‚ùå English translation file not found:', enPath);
    process.exit(1);
}

const translations = JSON.parse(fs.readFileSync(enPath, 'utf8'));

// Generate TypeScript interface from nested object
function generateInterface(obj, indentLevel = 1) {
    const indent = '  '.repeat(indentLevel);
    let result = '';

    for (const [key, value] of Object.entries(obj)) {
        // Escape keys that aren't valid identifiers
        const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;

        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            // Nested object
            result += `${indent}${safeKey}: {\n`;
            result += generateInterface(value, indentLevel + 1);
            result += `${indent}}\n`;
        } else {
            // String value
            result += `${indent}${safeKey}: string\n`;
        }
    }

    return result;
}

// Generate the TypeScript definition file
const typeDefinition = `/**
 * Auto-generated TypeScript definitions for i18n translations
 * Generated from: i18n/locales/en.json
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'node scripts/generate-i18n-types.cjs' to regenerate
 */

export interface I18nMessages {
${generateInterface(translations, 1).trimEnd()}
}

declare module '#app' {
  interface NuxtApp {
    $t: (key: TranslationKey, params?: Record<string, any>) => string
  }
}

declare module 'vue' {
  interface ComponentCustomProperties {
    $t: (key: TranslationKey, params?: Record<string, any>) => string
  }
}

// Generate literal type from all possible translation keys
type TranslationKey = ${generateKeyPaths(translations).map(k => `'${k}'`).join('\n  | ')}

export type { TranslationKey }
`;

// Helper to generate all possible key paths
function generateKeyPaths(obj, prefix = '') {
    let paths = [];

    for (const [key, value] of Object.entries(obj)) {
        const currentPath = prefix ? `${prefix}.${key}` : key;

        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            paths = paths.concat(generateKeyPaths(value, currentPath));
        } else {
            paths.push(currentPath);
        }
    }

    return paths;
}

// Write to types directory
const typesDir = path.join(__dirname, '../types');
if (!fs.existsSync(typesDir)) {
    fs.mkdirSync(typesDir, { recursive: true });
}

const outputPath = path.join(typesDir, 'i18n.d.ts');
fs.writeFileSync(outputPath, typeDefinition, 'utf8');

console.log('‚úÖ TypeScript definitions generated successfully!');
console.log(`üìÅ Output: ${path.relative(process.cwd(), outputPath)}`);
console.log(`üìä ${generateKeyPaths(translations).length} translation keys typed\n`);
console.log('üí° Usage:');
console.log('   const { $t } = useNuxtApp()');
console.log('   $t("common.header.products") // ‚úÖ Autocomplete works!');
console.log('   $t("invalid.key") // ‚ùå TypeScript error\n');
